# ЛАБОРАТОРНАЯ РАБОТА №1
# Предмет: Теория вероятностей и математическая статистика
# Тема: Статистическая обработка малой выборки
# Задания:
# 1. Построить эмпирическую функцию распределения F*(x).
# 2. Найти оценку математического ожидания.
# 3. Найти несмещенную оценку дисперсии и среднеквадратичного отклонения.
# 4. Найти доверительный интервал для математического ожидания и дисперсии при значениях доверительной вероятности
# β = 0, 9 и β = 0, 95.
# 5. Выдвинуть гипотезу и законе распределения генеральной совокупности. В качестве гипотического закона принять
# нормальный закон распределения.
# 6. На чертеже с графиком эмпирической функции F*(x) построить график теоретической функции F(x).
# 7. Оценить меру расхождения между теоретическим и статистическим распределениями по критерию Колмогорова.


# Импортируем модули

import pandas as pd
import numpy as np
import scipy.stats
from matplotlib import pyplot as plt

# Загрузим данные из .xlsx файла
df = pd.read_excel("data.xlsx")
# x = [4.71, 5.73, 6.42, 6.83, 6.83, 6.89, 7.03, 7.06, 7.57, 7.72, 7.72, 7.95, 8.03, 8.21, 8.28, 8.61, 9.12, 9.44,
# 10.27, 10.71]
x = df['Отсортированные данные'].tolist()
y = df["Накопленная частота"].tolist()
n = len(x)  # объем выборки


# Постороение эмпирической функции распределения на основе отсортированных данных.
def histogram():
    print("1. Построить эмпирическую функцию распределения F*(x).")
    fig, ax = plt.subplots()
    ax.bar(x, y, width=1.02)

    ax.set_title("Постороение эмпирической функции распределения на основе отсортированных данных")
    ax.set_xlabel("Экспериментальные данные")
    ax.set_ylabel("Накопленная частота")

    ax.set_facecolor('white')
    fig.set_facecolor('white')
    fig.set_figwidth(10)  # ширина Figure
    fig.set_figheight(6)  # высота Figure

    plt.show()
    # print(df.head(20))


# Оценка математического ожидания
def mathematical_expectation():
    print("\n2. Оценка математического ожидания")
    print("Объем выборки: " + str(len(x)) +
          "\nМаксимум: " + str("%.3f" % max(x)) +
          "\nМинимум: " + str("%.3f" % min(x)) +
          "\nРазмах выборки: " + str("%.1f" % ((max(x)) - min(x))))

    # Математическое ожидание - среднее значение случайной величины
    global mean
    mean = sum(x) / len(x)
    print("Математическое ожидание: " + str("%.3f" % mean))


# Несмещенная оценка дисперсии и среднеквадратичное отклонение
def standard_deviation():
    print("\n3. Найти несмещенную оценку дисперсии и среднеквадратичного отклонения.")
    # Несмещенная оценка дисперсии
    s2 = 1 / (len(x) - 1) * sum((i - mean) ** 2 for i in x)

    # Среднеквадратическое отклонение
    s2n = s2 ** (1 / 2)
    print("Несмещенная оценка дисперсии: " + str("%.3f" % s2) +
          "\nСреднеквадратическое отклонение: " + str("%.3f" % s2n))


# Доверительный интервал для математического ожидания и дисперсии при значениях доверительной вероятности
# β = 0. 9 и β = 0. 95.
def confidence_interval():
    print(
        "\n4. Найти доверительный интервал для математического ожидания и дисперсии при значениях доверительной"
        "вероятности β = 0. 9 и β = 0. 95.")
    confidence1 = 0.9
    confidence2 = 0.95
    # Доверительный интервал для математического ожидания
    a = 1.0 * np.array(x)
    n = len(a)
    m, se = np.mean(a), scipy.stats.sem(x)
    h1 = se * scipy.stats.t.ppf((1 + confidence1) / 2., n - 1)
    h2 = se * scipy.stats.t.ppf((1 + confidence2) / 2., n - 1)
    print("\tПри β = 0. 9, получаем: \t\t\t\t\tПри β = 0. 95, получаем:"
          "\n\tt-распределение: ", "%.3f" % scipy.stats.t.ppf((1 + confidence1) / 2., n - 1),
          "\t\t\t\t\tt-распределение: ", "%.3f" % scipy.stats.t.ppf((1 + confidence2) / 2., n - 1),
          "\n\tЛевая граница: ", str("%.3f" % (m - h1)), "\t\t\t\t\t\tЛевая граница: ", str("%.3f" % (m - h2)),
          "\n\tПравая граница: ", str("%.3f" % (m + h1)), "\t\t\t\t\t\tПравая граница: ", str("%.3f" % (m + h2)))

    # Выдвинуть гипотезу о законе распределения генеральной совокупности. В качестве гипотического закона принять
    # нормальный закон распределения.


def hypothesis():
    print(
        "\n5. Выдвинуть гипотезу и законе распределения генеральной совокупности. В качестве гипотического закона"
        "принять нормальный закон распределения.")
    print("Предполагаемый закон распределения — нормальный. Выдвигаем гипотезу H0 о подчинении "
          "случайной величины X нормальному закону распределения")


# На чертеже с графиком эмпирической функции F*(x) построить график теоретической функции F(x).
def theoretical_function():
    print(
        "\n6. На чертеже с графиком эмпирической функции F*(x) построить график теоретической функции F(x).")
    # print(np.random.normal(loc=1.446, scale=7.757, size=20))
    # loc - среднее значение случайно величины
    # scale - среднее отклонение случайно величины
    cdf = scipy.stats.norm.cdf(x, loc=7.757, scale=1.446)

    fig = plt.figure(figsize=(10, 5))
    ax = fig.add_subplot()

    # ax.set_title("График теоретический функции")
    # ax.set_xlabel("Экспериментальные данные")
    # ax.set_ylabel("Накопленная частота")

    ax.step(x, y, label="F(x)")
    ax.plot(x, cdf, color='red', label="Частота")
    ax.grid()
    ax.legend()

    plt.show()
    # print(cdf)


# Оценить меру расхождения между теоретическим и статистическим распределениями по критерию Колмогорова.
def kolmogorov_criterion():
    print(
        "\n7. Оценить меру расхождения между теоретическим и статистическим распределениями по критерию Колмогорова.")
    cdf = scipy.stats.norm.cdf(x, loc=7.757, scale=1.446)
    # Вычислим максимальное значение модуля разности между значениями эмпирической и теоретической функциями:
    u = max(y - cdf)
    print("Максимальное значение модуля разности между значениями эмпирической и теоретической функциями: U =",
          "%.2f" % u)
    # Вычислям лямбда0:
    lambda0 = u * np.sqrt(n)
    print("lambda0 =", "%.2f" % lambda0)
    # Проверим выполнение условий для критерия Колмогорова
    # alpha = 0.01
    lambda_kr1 = 1.63
    # alpha = 0.05
    lambda_kr2 = 1.36
    if lambda_kr1 > lambda0 and lambda_kr2 > lambda0:
        print(
            "\nГипотеза о нормальном распределении по критерию Колмогорова принимается как не противоречащая опытном "
            "данным.")


def main():
    histogram()
    mathematical_expectation()
    standard_deviation()
    confidence_interval()
    hypothesis()
    theoretical_function()
    kolmogorov_criterion()


if __name__ == '__main__':
    main()
